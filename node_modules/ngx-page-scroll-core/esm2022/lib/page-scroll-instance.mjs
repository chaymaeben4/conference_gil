/**
 * Represents a scrolling action
 */
export class PageScrollInstance {
    /**
     * Private constructor, requires the properties assumed to be the bare minimum.
     * Use the factory methods to create instances:
     *      {@link PageScrollService#create}
     */
    constructor(pageScrollOptions) {
        /**
         * These properties will be set/manipulated if the scroll animation starts
         */
        /* The initial value of the scrollTop or scrollLeft position when the animation starts */
        this.startScrollPosition = 0;
        /* Whether an interrupt listener is attached to the body or not */
        this.interruptListenersAttached = false;
        /* References to the timer instance that is used to perform the scroll animation to be
         able to clear it on animation end*/
        this.timer = null;
        if (!pageScrollOptions.scrollViews || pageScrollOptions.scrollViews.length === 0) {
            pageScrollOptions.scrollViews = [
                pageScrollOptions.document.documentElement,
                pageScrollOptions.document.body,
                pageScrollOptions.document.body.parentNode,
            ];
            this.isInlineScrolling = false;
        }
        else {
            this.isInlineScrolling = true;
        }
        this.pageScrollOptions = pageScrollOptions;
    }
    static getScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {
        const body = pageScrollOptions.document.body;
        const docEl = pageScrollOptions.document.documentElement;
        const windowPageYOffset = pageScrollOptions.document.defaultView &&
            pageScrollOptions.document.defaultView.pageYOffset || undefined;
        const windowPageXOffset = pageScrollOptions.document.defaultView &&
            pageScrollOptions.document.defaultView.pageXOffset || undefined;
        const scrollTop = windowPageYOffset || docEl.scrollTop || body.scrollTop;
        const scrollLeft = windowPageXOffset || docEl.scrollLeft || body.scrollLeft;
        const clientTop = docEl.clientTop || body.clientTop || 0;
        const clientLeft = docEl.clientLeft || body.clientLeft || 0;
        if (scrollTargetElement === undefined || scrollTargetElement === null) {
            // No element found, so return the current position to not cause any change in scroll position
            return { top: scrollTop, left: scrollLeft };
        }
        const box = scrollTargetElement.getBoundingClientRect();
        const top = box.top + scrollTop - clientTop;
        const left = box.left + scrollLeft - clientLeft;
        return { top: Math.round(top), left: Math.round(left) };
    }
    static getInlineScrollingTargetPosition(pageScrollOptions, scrollTargetElement) {
        const position = { top: scrollTargetElement.offsetTop, left: scrollTargetElement.offsetLeft };
        if (pageScrollOptions.advancedInlineOffsetCalculation && pageScrollOptions.scrollViews.length === 1) {
            const accumulatedParentsPos = { top: 0, left: 0 };
            // not named window to make sure we're not getting the global window variable by accident
            const theWindow = scrollTargetElement.ownerDocument.defaultView;
            let parentFound = false;
            // Start parent is the immediate parent
            let parent = scrollTargetElement.parentElement;
            // Iterate upwards all parents
            while (!parentFound && parent !== undefined && parent !== null) {
                if (theWindow.getComputedStyle(parent).getPropertyValue('position') === 'relative') {
                    accumulatedParentsPos.top += parent.offsetTop;
                    accumulatedParentsPos.left += parent.offsetLeft;
                }
                // Next iteration
                parent = parent.parentElement;
                parentFound = parent === pageScrollOptions.scrollViews[0];
            }
            if (parentFound) {
                // Only use the results if we found the parent, otherwise we accumulated too much anyway
                position.top += accumulatedParentsPos.top;
                position.left += accumulatedParentsPos.left;
            }
            else {
                /* TODO Uncomment
                if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {
                  console.warn('Unable to find nested scrolling targets parent!');
                }*/
            }
        }
        return position;
    }
    getScrollPropertyValue(scrollingView) {
        if (!this.pageScrollOptions.verticalScrolling) {
            return scrollingView.scrollLeft;
        }
        return scrollingView.scrollTop;
    }
    getScrollClientPropertyValue(scrollingView) {
        if (!this.pageScrollOptions.verticalScrolling) {
            return scrollingView.clientWidth;
        }
        return scrollingView.clientHeight;
    }
    /**
     * Extract the exact location of the scrollTarget element.
     *
     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be
     * a string like "#heading2", then this method returns the corresponding DOM element for that id.
     *
     */
    extractScrollTargetPosition() {
        const scrollTargetElement = this.getScrollTargetElement();
        if (scrollTargetElement === null || scrollTargetElement === undefined) {
            // Scroll target not found
            return { top: NaN, left: NaN };
        }
        if (this.isInlineScrolling) {
            return PageScrollInstance.getInlineScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);
        }
        return PageScrollInstance.getScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);
    }
    /**
     * Get the top offset of the scroll animation.
     * This automatically takes the offset location of the scrolling container/scrolling view
     * into account (for nested/inline scrolling).
     */
    getCurrentOffset() {
        return this.pageScrollOptions.scrollOffset;
    }
    /**
     * Sets the "scrollTop" or "scrollLeft" property for all scrollViews to the provided value
     * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.
     *          false if it failed for all ScrollViews, meaning that we should stop the animation
     *          (probably because we're at the end of the scrolling region)
     */
    setScrollPosition(position) {
        // Set the new scrollTop/scrollLeft to all scrollViews elements
        return this.pageScrollOptions.scrollViews.reduce((oneAlreadyWorked, scrollingView) => {
            const startScrollPropertyValue = this.getScrollPropertyValue(scrollingView);
            if (scrollingView && startScrollPropertyValue !== undefined && startScrollPropertyValue !== null) {
                const scrollDistance = Math.abs(startScrollPropertyValue - position);
                // The movement we need to perform is less than 2px
                // This we consider a small movement which some browser may not perform when
                // changing the scrollTop/scrollLeft property
                // Thus in this cases we do not stop the scroll animation, although setting the
                // scrollTop/scrollLeft value "fails"
                const isSmallMovement = scrollDistance < this.pageScrollOptions._minScrollDistance;
                if (!this.pageScrollOptions.verticalScrolling) {
                    scrollingView.scrollLeft = position;
                }
                else {
                    scrollingView.scrollTop = position;
                }
                // Return true if setting the new scrollTop/scrollLeft value worked
                // We consider that it worked if the new scrollTop/scrollLeft value is closer to the
                // desired scrollTop/scrollLeft than before (it might not be exactly the value we
                // set due to dpi or rounding irregularities)
                if (isSmallMovement || scrollDistance > Math.abs(this.getScrollPropertyValue(scrollingView) - position)) {
                    return true;
                }
            }
            return oneAlreadyWorked;
        }, false);
    }
    /**
     * Trigger firing a animation finish event
     * @param value Whether the animation finished at the target (true) or got interrupted (false)
     */
    fireEvent(value) {
        if (this.pageScrollOptions.scrollFinishListener) {
            this.pageScrollOptions.scrollFinishListener.emit(value);
        }
    }
    /**
     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter
     * will be called if any of the attached events is fired.
     *
     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.
     */
    attachInterruptListeners(interruptReporter) {
        if (this.interruptListenersAttached) {
            // Detach possibly existing listeners first
            this.detachInterruptListeners();
        }
        this.interruptListener = (event) => {
            interruptReporter.report(event, this);
        };
        this.pageScrollOptions.interruptEvents.forEach((event) => this.pageScrollOptions.document.body.addEventListener(event, this.interruptListener));
        this.interruptListenersAttached = true;
    }
    /**
     * Remove event listeners from the body and stop listening for events that might be treated as "animation
     * interrupt" events.
     */
    detachInterruptListeners() {
        this.pageScrollOptions.interruptEvents.forEach((event) => this.pageScrollOptions.document.body.removeEventListener(event, this.interruptListener));
        this.interruptListenersAttached = false;
    }
    getScrollTargetElement() {
        if (typeof this.pageScrollOptions.scrollTarget === 'string') {
            const targetSelector = this.pageScrollOptions.scrollTarget;
            if (targetSelector.match(/^#[^\s]+$/g) !== null) {
                // It's an id selector and a valid id, as it does not contain any white space characters
                return this.pageScrollOptions.document.getElementById(targetSelector.substr(1));
            }
            return this.pageScrollOptions.document.querySelector(targetSelector);
        }
        return this.pageScrollOptions.scrollTarget;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnZS1zY3JvbGwtaW5zdGFuY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtcGFnZS1zY3JvbGwtY29yZS9zcmMvbGliL3BhZ2Utc2Nyb2xsLWluc3RhbmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1EQTs7R0FFRztBQUNILE1BQU0sT0FBTyxrQkFBa0I7SUFnQzdCOzs7O09BSUc7SUFDSCxZQUFZLGlCQUFvQztRQTNCaEQ7O1dBRUc7UUFDSCx5RkFBeUY7UUFDbEYsd0JBQW1CLEdBQUcsQ0FBQyxDQUFDO1FBVy9CLGtFQUFrRTtRQUMzRCwrQkFBMEIsR0FBRyxLQUFLLENBQUM7UUFFMUM7NENBQ29DO1FBQzdCLFVBQUssR0FBRyxJQUFJLENBQUM7UUFRbEIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsSUFBSSxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNoRixpQkFBaUIsQ0FBQyxXQUFXLEdBQUc7Z0JBQzlCLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxlQUFlO2dCQUMxQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsSUFBSTtnQkFDL0IsaUJBQWlCLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFVO2FBQzNDLENBQUM7WUFDRixJQUFJLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDO1NBQ2hDO2FBQU07WUFDTCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDO1NBQy9CO1FBRUQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLGlCQUFpQixDQUFDO0lBQzdDLENBQUM7SUFFTyxNQUFNLENBQUMsMEJBQTBCLENBQUMsaUJBQW9DLEVBQ3BDLG1CQUFnQztRQUN4RSxNQUFNLElBQUksR0FBRyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO1FBQzdDLE1BQU0sS0FBSyxHQUFHLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUM7UUFF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SUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksS0FBSyxRQUFRLEVBQUU7WUFDM0QsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQXNCLENBQUM7WUFDckUsSUFBSSxjQUFjLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLElBQUksRUFBRTtnQkFDL0Msd0ZBQXdGO2dCQUV4RixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNqRjtZQUVELE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFnQixDQUFDO1NBQ3JGO1FBRUQsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBMkIsQ0FBQztJQUM1RCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFBhZ2VTY3JvbGxDb25maWcgfSBmcm9tICcuL3R5cGVzL3BhZ2Utc2Nyb2xsLmNvbmZpZyc7XG5pbXBvcnQgeyBQYWdlU2Nyb2xsVGFyZ2V0IH0gZnJvbSAnLi90eXBlcy9wYWdlLXNjcm9sbC10YXJnZXQnO1xuaW1wb3J0IHsgUGFnZVNjcm9sbFZpZXdzIH0gZnJvbSAnLi90eXBlcy9wYWdlLXNjcm9sbC12aWV3JztcbmltcG9ydCB7IEVhc2luZ0xvZ2ljIH0gZnJvbSAnLi90eXBlcy9lYXNpbmctbG9naWMnO1xuXG4vKipcbiAqIEFuIEludGVyZmFjZSBzcGVjaWZ5aW5nIHRoZSBwb3NzaWJsZSBvcHRpb25zIHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBuZXdJbnN0YW5jZSgpIGZhY3RvcnkgbWV0aG9kXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZVNjcm9sbE9wdGlvbnMgZXh0ZW5kcyBQYWdlU2Nyb2xsQ29uZmlnIHtcbiAgLyoqXG4gICAqIFRoZSBkb2N1bWVudCBvYmplY3Qgb2YgdGhlIGN1cnJlbnQgYXBwXG4gICAqL1xuICBkb2N1bWVudDogRG9jdW1lbnQ7XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lmaWNhdGlvbiBvZiB0aGUgRE9NIGVsZW1lbnQgdG8gc2Nyb2xsIHRvLiBFaXRoZXIgYSBzdHJpbmcgcmVmZXJyaW5nIHRvIGFuXG4gICAqIGVsZW1lbnQgdXNpbmcgYSB2YWxpZCBjc3Mgc2VsZWN0b3IgKGAjdGFyZ2V0YCwgYC5jbGFzc2AsIGBkaXYuY2xhc3NgKSBvciBhIEhUTUxFbGVtZW50XG4gICAqIHRoYXQgaXMgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50J3MgRE9NIHRyZWUuXG4gICAqL1xuICBzY3JvbGxUYXJnZXQ6IFBhZ2VTY3JvbGxUYXJnZXQ7XG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIEhUTUxFbGVtZW50cyBvciB0aGUgYm9keSBvYmplY3QgdGhhdCBzaG91bGQgYmUgbWFuaXB1bGF0ZWQgd2hpbGUgcGVyZm9ybWluZ1xuICAgKiB0aGUgc2Nyb2xsIGFuaW1hdGlvbi5cbiAgICovXG4gIHNjcm9sbFZpZXdzPzogUGFnZVNjcm9sbFZpZXdzW107XG5cbiAgLyoqXG4gICAqIE1heGltdW0gc3BlZWQgdG8gYmUgdXNlZCBmb3IgdGhlIHNjcm9sbCBhbmltYXRpb24uIE9ubHkgdGFrZW5cbiAgICogaW50byBhY2NvdW50IG9mIG5vIGR1cmF0aW9uIGlzIHByb3ZpZGVkXG4gICAqL1xuICBzcGVlZD86IG51bWJlcjtcblxuICAvKipcbiAgICogQSBsaXN0ZW5lciB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHNjcm9sbCBhbmltYXRpb24gc3RvcHNcbiAgICovXG4gIHNjcm9sbEZpbmlzaExpc3RlbmVyPzogRXZlbnRFbWl0dGVyPGJvb2xlYW4+O1xuXG4gIG5hbWVzcGFjZT86IHN0cmluZztcbiAgdmVydGljYWxTY3JvbGxpbmc/OiBib29sZWFuO1xuICBkdXJhdGlvbj86IG51bWJlcjtcbiAgc2Nyb2xsT2Zmc2V0PzogbnVtYmVyO1xuICBhZHZhbmNlZElubGluZU9mZnNldENhbGN1bGF0aW9uPzogYm9vbGVhbjtcbiAgaW50ZXJydXB0RXZlbnRzPzogc3RyaW5nW107XG4gIGludGVycnVwdEtleXM/OiBzdHJpbmdbXTtcbiAgaW50ZXJydXB0aWJsZT86IGJvb2xlYW47XG4gIHNjcm9sbEluVmlldz86IGJvb2xlYW47XG4gIGVhc2luZ0xvZ2ljPzogRWFzaW5nTG9naWM7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHNjcm9sbGluZyBhY3Rpb25cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VTY3JvbGxJbnN0YW5jZSB7XG5cbiAgcHVibGljIHBhZ2VTY3JvbGxPcHRpb25zOiBQYWdlU2Nyb2xsT3B0aW9ucztcblxuICBwcml2YXRlIGlzSW5saW5lU2Nyb2xsaW5nOiBib29sZWFuO1xuXG4gIC8qIFRoZSBsaXN0ZW5lciB0aGF0IHRoaXMgc2Nyb2xsIGluc3RhbmNlIGF0dGFjaGVzIHRvIHRoZSBib2R5IHRvIGxpc3RlbiBmb3IgaW50ZXJydXB0IGV2ZW50c1xuICBXZSdyZSBrZWVwaW5nIGEgcmVmZXJlbmNlIHRvIGl0IHNvIHdlIGNhbiBwcm9wZXJseSByZW1vdmUgaXQgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzICovXG4gIHByaXZhdGUgaW50ZXJydXB0TGlzdGVuZXI6IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3Q7XG5cbiAgLyoqXG4gICAqIFRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZSBzZXQvbWFuaXB1bGF0ZWQgaWYgdGhlIHNjcm9sbCBhbmltYXRpb24gc3RhcnRzXG4gICAqL1xuICAvKiBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQgcG9zaXRpb24gd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0cyAqL1xuICBwdWJsaWMgc3RhcnRTY3JvbGxQb3NpdGlvbiA9IDA7XG4gIC8qIFRoZSB0YXJnZXQgdmFsdWUgb2YgdGhlIHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0IHBvc2l0aW9uIGZvciB0aGUgYW5pbWF0aW9uIChha2EgXCJ0aGUgZmluYWwgZGVzdGluYXRpb25cIikgKi9cbiAgcHVibGljIHRhcmdldFNjcm9sbFBvc2l0aW9uOiBudW1iZXI7XG4gIC8qIERpZmZlcmVuY2UgYmV0d2VlbiBzdGFydFNjcm9sbFBvc2l0aW9uIGFuZCB0YXJnZXRTY3JvbGxQb3NpdGlvbi4gUHJlLWNhbGN1bGF0ZWQgdG8gbWluaW1pemUgY29tcHV0YXRpb25zIGR1cmluZyBhbmltYXRpb24gKi9cbiAgcHVibGljIGRpc3RhbmNlVG9TY3JvbGw6IG51bWJlcjtcbiAgLyogVGhlIHRpbWVzdGFtcCB3aGVuIHRoZSBhbmltYXRpb24gc3RhcnRzL2dvdCBzdGFydGVkICovXG4gIHB1YmxpYyBzdGFydFRpbWU6IG51bWJlcjtcbiAgLyogVGhlIGVzdGltYXRlIGVuZCB0aW1lIG9mIHRoZSBhbmltYXRpb24sIGNhbGN1bGF0ZWQgYnkgc3RhcnRUaW1lICsgZHVyYXRpb24gKi9cbiAgcHVibGljIGVuZFRpbWU6IG51bWJlcjtcbiAgLyogVGhlIGR1cmF0aW9uIGEgc3RhcnRlZCBhbmltYXRpb24gdGFrZXMuIFRoaXMgbWF5IG1hdGNoIHRoZSBfZHVyYXRpb24gb3IgYmUgYWRqdXN0ZWQgZHVlIHRvIHRoZSBfc3BlZWQgb3B0aW9uICovXG4gIHB1YmxpYyBleGVjdXRpb25EdXJhdGlvbjogbnVtYmVyO1xuICAvKiBXaGV0aGVyIGFuIGludGVycnVwdCBsaXN0ZW5lciBpcyBhdHRhY2hlZCB0byB0aGUgYm9keSBvciBub3QgKi9cbiAgcHVibGljIGludGVycnVwdExpc3RlbmVyc0F0dGFjaGVkID0gZmFsc2U7XG5cbiAgLyogUmVmZXJlbmNlcyB0byB0aGUgdGltZXIgaW5zdGFuY2UgdGhhdCBpcyB1c2VkIHRvIHBlcmZvcm0gdGhlIHNjcm9sbCBhbmltYXRpb24gdG8gYmVcbiAgIGFibGUgdG8gY2xlYXIgaXQgb24gYW5pbWF0aW9uIGVuZCovXG4gIHB1YmxpYyB0aW1lciA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgY29uc3RydWN0b3IsIHJlcXVpcmVzIHRoZSBwcm9wZXJ0aWVzIGFzc3VtZWQgdG8gYmUgdGhlIGJhcmUgbWluaW11bS5cbiAgICogVXNlIHRoZSBmYWN0b3J5IG1ldGhvZHMgdG8gY3JlYXRlIGluc3RhbmNlczpcbiAgICogICAgICB7QGxpbmsgUGFnZVNjcm9sbFNlcnZpY2UjY3JlYXRlfVxuICAgKi9cbiAgY29uc3RydWN0b3IocGFnZVNjcm9sbE9wdGlvbnM6IFBhZ2VTY3JvbGxPcHRpb25zKSB7XG4gICAgaWYgKCFwYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxWaWV3cyB8fCBwYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxWaWV3cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHBhZ2VTY3JvbGxPcHRpb25zLnNjcm9sbFZpZXdzID0gW1xuICAgICAgICBwYWdlU2Nyb2xsT3B0aW9ucy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgIHBhZ2VTY3JvbGxPcHRpb25zLmRvY3VtZW50LmJvZHksXG4gICAgICAgIHBhZ2VTY3JvbGxPcHRpb25zLmRvY3VtZW50LmJvZHkucGFyZW50Tm9kZSxcbiAgICAgIF07XG4gICAgICB0aGlzLmlzSW5saW5lU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNJbmxpbmVTY3JvbGxpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMucGFnZVNjcm9sbE9wdGlvbnMgPSBwYWdlU2Nyb2xsT3B0aW9ucztcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldFNjcm9sbGluZ1RhcmdldFBvc2l0aW9uKHBhZ2VTY3JvbGxPcHRpb25zOiBQYWdlU2Nyb2xsT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0RWxlbWVudDogSFRNTEVsZW1lbnQpOiB7IHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIgfSB7XG4gICAgY29uc3QgYm9keSA9IHBhZ2VTY3JvbGxPcHRpb25zLmRvY3VtZW50LmJvZHk7XG4gICAgY29uc3QgZG9jRWwgPSBwYWdlU2Nyb2xsT3B0aW9ucy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICBjb25zdCB3aW5kb3dQYWdlWU9mZnNldDogbnVtYmVyID0gcGFnZVNjcm9sbE9wdGlvbnMuZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiZcbiAgICAgIHBhZ2VTY3JvbGxPcHRpb25zLmRvY3VtZW50LmRlZmF1bHRWaWV3LnBhZ2VZT2Zmc2V0IHx8IHVuZGVmaW5lZDtcbiAgICBjb25zdCB3aW5kb3dQYWdlWE9mZnNldDogbnVtYmVyID0gcGFnZVNjcm9sbE9wdGlvbnMuZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiZcbiAgICAgIHBhZ2VTY3JvbGxPcHRpb25zLmRvY3VtZW50LmRlZmF1bHRWaWV3LnBhZ2VYT2Zmc2V0IHx8IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHdpbmRvd1BhZ2VZT2Zmc2V0IHx8IGRvY0VsLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcDtcbiAgICBjb25zdCBzY3JvbGxMZWZ0ID0gd2luZG93UGFnZVhPZmZzZXQgfHwgZG9jRWwuc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQ7XG5cbiAgICBjb25zdCBjbGllbnRUb3AgPSBkb2NFbC5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMDtcbiAgICBjb25zdCBjbGllbnRMZWZ0ID0gZG9jRWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMDtcblxuICAgIGlmIChzY3JvbGxUYXJnZXRFbGVtZW50ID09PSB1bmRlZmluZWQgfHwgc2Nyb2xsVGFyZ2V0RWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gTm8gZWxlbWVudCBmb3VuZCwgc28gcmV0dXJuIHRoZSBjdXJyZW50IHBvc2l0aW9uIHRvIG5vdCBjYXVzZSBhbnkgY2hhbmdlIGluIHNjcm9sbCBwb3NpdGlvblxuICAgICAgcmV0dXJuIHt0b3A6IHNjcm9sbFRvcCwgbGVmdDogc2Nyb2xsTGVmdH07XG4gICAgfVxuICAgIGNvbnN0IGJveCA9IHNjcm9sbFRhcmdldEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBjb25zdCB0b3AgPSBib3gudG9wICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wO1xuICAgIGNvbnN0IGxlZnQgPSBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0O1xuXG4gICAgcmV0dXJuIHt0b3A6IE1hdGgucm91bmQodG9wKSwgbGVmdDogTWF0aC5yb3VuZChsZWZ0KX07XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRJbmxpbmVTY3JvbGxpbmdUYXJnZXRQb3NpdGlvbihwYWdlU2Nyb2xsT3B0aW9uczogUGFnZVNjcm9sbE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldEVsZW1lbnQ6IEhUTUxFbGVtZW50KTogeyB0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0ge3RvcDogc2Nyb2xsVGFyZ2V0RWxlbWVudC5vZmZzZXRUb3AsIGxlZnQ6IHNjcm9sbFRhcmdldEVsZW1lbnQub2Zmc2V0TGVmdH07XG4gICAgaWYgKHBhZ2VTY3JvbGxPcHRpb25zLmFkdmFuY2VkSW5saW5lT2Zmc2V0Q2FsY3VsYXRpb24gJiYgcGFnZVNjcm9sbE9wdGlvbnMuc2Nyb2xsVmlld3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBhY2N1bXVsYXRlZFBhcmVudHNQb3MgPSB7dG9wOiAwLCBsZWZ0OiAwfTtcbiAgICAgIC8vIG5vdCBuYW1lZCB3aW5kb3cgdG8gbWFrZSBzdXJlIHdlJ3JlIG5vdCBnZXR0aW5nIHRoZSBnbG9iYWwgd2luZG93IHZhcmlhYmxlIGJ5IGFjY2lkZW50XG4gICAgICBjb25zdCB0aGVXaW5kb3cgPSBzY3JvbGxUYXJnZXRFbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICBsZXQgcGFyZW50Rm91bmQgPSBmYWxzZTtcblxuICAgICAgLy8gU3RhcnQgcGFyZW50IGlzIHRoZSBpbW1lZGlhdGUgcGFyZW50XG4gICAgICBsZXQgcGFyZW50ID0gc2Nyb2xsVGFyZ2V0RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXG4gICAgICAvLyBJdGVyYXRlIHVwd2FyZHMgYWxsIHBhcmVudHNcbiAgICAgIHdoaWxlICghcGFyZW50Rm91bmQgJiYgcGFyZW50ICE9PSB1bmRlZmluZWQgJiYgcGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGVXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdyZWxhdGl2ZScpIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFBhcmVudHNQb3MudG9wICs9IHBhcmVudC5vZmZzZXRUb3A7XG4gICAgICAgICAgYWNjdW11bGF0ZWRQYXJlbnRzUG9zLmxlZnQgKz0gcGFyZW50Lm9mZnNldExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV4dCBpdGVyYXRpb25cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHBhcmVudEZvdW5kID0gcGFyZW50ID09PSBwYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxWaWV3c1swXTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRGb3VuZCkge1xuICAgICAgICAvLyBPbmx5IHVzZSB0aGUgcmVzdWx0cyBpZiB3ZSBmb3VuZCB0aGUgcGFyZW50LCBvdGhlcndpc2Ugd2UgYWNjdW11bGF0ZWQgdG9vIG11Y2ggYW55d2F5XG4gICAgICAgIHBvc2l0aW9uLnRvcCArPSBhY2N1bXVsYXRlZFBhcmVudHNQb3MudG9wO1xuICAgICAgICBwb3NpdGlvbi5sZWZ0ICs9IGFjY3VtdWxhdGVkUGFyZW50c1Bvcy5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogVE9ETyBVbmNvbW1lbnRcbiAgICAgICAgaWYgKFBhZ2VTY3JvbGxDb25maWcuX2xvZ0xldmVsID49IDIgfHwgKFBhZ2VTY3JvbGxDb25maWcuX2xvZ0xldmVsID49IDEgJiYgaXNEZXZNb2RlKCkpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gZmluZCBuZXN0ZWQgc2Nyb2xsaW5nIHRhcmdldHMgcGFyZW50IScpO1xuICAgICAgICB9Ki9cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH1cblxuICBwdWJsaWMgZ2V0U2Nyb2xsUHJvcGVydHlWYWx1ZShzY3JvbGxpbmdWaWV3KTogbnVtYmVyIHtcbiAgICBpZiAoIXRoaXMucGFnZVNjcm9sbE9wdGlvbnMudmVydGljYWxTY3JvbGxpbmcpIHtcbiAgICAgIHJldHVybiBzY3JvbGxpbmdWaWV3LnNjcm9sbExlZnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjcm9sbGluZ1ZpZXcuc2Nyb2xsVG9wO1xuICB9XG5cbiAgcHVibGljIGdldFNjcm9sbENsaWVudFByb3BlcnR5VmFsdWUoc2Nyb2xsaW5nVmlldyk6IG51bWJlciB7XG4gICAgaWYgKCF0aGlzLnBhZ2VTY3JvbGxPcHRpb25zLnZlcnRpY2FsU2Nyb2xsaW5nKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsaW5nVmlldy5jbGllbnRXaWR0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2Nyb2xsaW5nVmlldy5jbGllbnRIZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgZXhhY3QgbG9jYXRpb24gb2YgdGhlIHNjcm9sbFRhcmdldCBlbGVtZW50LlxuICAgKlxuICAgKiBFeHRyYWN0IHRoZSBzY3JvbGxUYXJnZXQgSFRNTEVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gUGFnZVNjcm9sbFRhcmdldCBvYmplY3QuIFRoZSBsYXR0ZXIgb25lIG1heSBiZVxuICAgKiBhIHN0cmluZyBsaWtlIFwiI2hlYWRpbmcyXCIsIHRoZW4gdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBET00gZWxlbWVudCBmb3IgdGhhdCBpZC5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBleHRyYWN0U2Nyb2xsVGFyZ2V0UG9zaXRpb24oKTogeyB0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IHNjcm9sbFRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFNjcm9sbFRhcmdldEVsZW1lbnQoKTtcblxuICAgIGlmIChzY3JvbGxUYXJnZXRFbGVtZW50ID09PSBudWxsIHx8IHNjcm9sbFRhcmdldEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2Nyb2xsIHRhcmdldCBub3QgZm91bmRcbiAgICAgIHJldHVybiB7dG9wOiBOYU4sIGxlZnQ6IE5hTn07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNJbmxpbmVTY3JvbGxpbmcpIHtcbiAgICAgIHJldHVybiBQYWdlU2Nyb2xsSW5zdGFuY2UuZ2V0SW5saW5lU2Nyb2xsaW5nVGFyZ2V0UG9zaXRpb24odGhpcy5wYWdlU2Nyb2xsT3B0aW9ucywgc2Nyb2xsVGFyZ2V0RWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBhZ2VTY3JvbGxJbnN0YW5jZS5nZXRTY3JvbGxpbmdUYXJnZXRQb3NpdGlvbih0aGlzLnBhZ2VTY3JvbGxPcHRpb25zLCBzY3JvbGxUYXJnZXRFbGVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRvcCBvZmZzZXQgb2YgdGhlIHNjcm9sbCBhbmltYXRpb24uXG4gICAqIFRoaXMgYXV0b21hdGljYWxseSB0YWtlcyB0aGUgb2Zmc2V0IGxvY2F0aW9uIG9mIHRoZSBzY3JvbGxpbmcgY29udGFpbmVyL3Njcm9sbGluZyB2aWV3XG4gICAqIGludG8gYWNjb3VudCAoZm9yIG5lc3RlZC9pbmxpbmUgc2Nyb2xsaW5nKS5cbiAgICovXG4gIHB1YmxpYyBnZXRDdXJyZW50T2Zmc2V0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFnZVNjcm9sbE9wdGlvbnMuc2Nyb2xsT2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIFwic2Nyb2xsVG9wXCIgb3IgXCJzY3JvbGxMZWZ0XCIgcHJvcGVydHkgZm9yIGFsbCBzY3JvbGxWaWV3cyB0byB0aGUgcHJvdmlkZWQgdmFsdWVcbiAgICogQHJldHVybiB0cnVlIGlmIGF0IGxlYXN0IGZvciBvbmUgU2Nyb2xsVG9wU291cmNlIHRoZSBzY3JvbGxUb3Avc2Nyb2xsTGVmdCB2YWx1ZSBjb3VsZCBiZSBzZXQgYW5kIGl0IGtlcHQgdGhlIG5ldyB2YWx1ZS5cbiAgICogICAgICAgICAgZmFsc2UgaWYgaXQgZmFpbGVkIGZvciBhbGwgU2Nyb2xsVmlld3MsIG1lYW5pbmcgdGhhdCB3ZSBzaG91bGQgc3RvcCB0aGUgYW5pbWF0aW9uXG4gICAqICAgICAgICAgIChwcm9iYWJseSBiZWNhdXNlIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIHNjcm9sbGluZyByZWdpb24pXG4gICAqL1xuICBwdWJsaWMgc2V0U2Nyb2xsUG9zaXRpb24ocG9zaXRpb246IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIC8vIFNldCB0aGUgbmV3IHNjcm9sbFRvcC9zY3JvbGxMZWZ0IHRvIGFsbCBzY3JvbGxWaWV3cyBlbGVtZW50c1xuICAgIHJldHVybiB0aGlzLnBhZ2VTY3JvbGxPcHRpb25zLnNjcm9sbFZpZXdzLnJlZHVjZSgob25lQWxyZWFkeVdvcmtlZCwgc2Nyb2xsaW5nVmlldzogYW55KSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgY29uc3Qgc3RhcnRTY3JvbGxQcm9wZXJ0eVZhbHVlID0gdGhpcy5nZXRTY3JvbGxQcm9wZXJ0eVZhbHVlKHNjcm9sbGluZ1ZpZXcpO1xuICAgICAgaWYgKHNjcm9sbGluZ1ZpZXcgJiYgc3RhcnRTY3JvbGxQcm9wZXJ0eVZhbHVlICE9PSB1bmRlZmluZWQgJiYgc3RhcnRTY3JvbGxQcm9wZXJ0eVZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbERpc3RhbmNlID0gTWF0aC5hYnMoc3RhcnRTY3JvbGxQcm9wZXJ0eVZhbHVlIC0gcG9zaXRpb24pO1xuXG4gICAgICAgIC8vIFRoZSBtb3ZlbWVudCB3ZSBuZWVkIHRvIHBlcmZvcm0gaXMgbGVzcyB0aGFuIDJweFxuICAgICAgICAvLyBUaGlzIHdlIGNvbnNpZGVyIGEgc21hbGwgbW92ZW1lbnQgd2hpY2ggc29tZSBicm93c2VyIG1heSBub3QgcGVyZm9ybSB3aGVuXG4gICAgICAgIC8vIGNoYW5naW5nIHRoZSBzY3JvbGxUb3Avc2Nyb2xsTGVmdCBwcm9wZXJ0eVxuICAgICAgICAvLyBUaHVzIGluIHRoaXMgY2FzZXMgd2UgZG8gbm90IHN0b3AgdGhlIHNjcm9sbCBhbmltYXRpb24sIGFsdGhvdWdoIHNldHRpbmcgdGhlXG4gICAgICAgIC8vIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IHZhbHVlIFwiZmFpbHNcIlxuICAgICAgICBjb25zdCBpc1NtYWxsTW92ZW1lbnQgPSBzY3JvbGxEaXN0YW5jZSA8IHRoaXMucGFnZVNjcm9sbE9wdGlvbnMuX21pblNjcm9sbERpc3RhbmNlO1xuXG4gICAgICAgIGlmICghdGhpcy5wYWdlU2Nyb2xsT3B0aW9ucy52ZXJ0aWNhbFNjcm9sbGluZykge1xuICAgICAgICAgIHNjcm9sbGluZ1ZpZXcuc2Nyb2xsTGVmdCA9IHBvc2l0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbGluZ1ZpZXcuc2Nyb2xsVG9wID0gcG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdHJ1ZSBpZiBzZXR0aW5nIHRoZSBuZXcgc2Nyb2xsVG9wL3Njcm9sbExlZnQgdmFsdWUgd29ya2VkXG4gICAgICAgIC8vIFdlIGNvbnNpZGVyIHRoYXQgaXQgd29ya2VkIGlmIHRoZSBuZXcgc2Nyb2xsVG9wL3Njcm9sbExlZnQgdmFsdWUgaXMgY2xvc2VyIHRvIHRoZVxuICAgICAgICAvLyBkZXNpcmVkIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IHRoYW4gYmVmb3JlIChpdCBtaWdodCBub3QgYmUgZXhhY3RseSB0aGUgdmFsdWUgd2VcbiAgICAgICAgLy8gc2V0IGR1ZSB0byBkcGkgb3Igcm91bmRpbmcgaXJyZWd1bGFyaXRpZXMpXG4gICAgICAgIGlmIChpc1NtYWxsTW92ZW1lbnQgfHwgc2Nyb2xsRGlzdGFuY2UgPiBNYXRoLmFicyh0aGlzLmdldFNjcm9sbFByb3BlcnR5VmFsdWUoc2Nyb2xsaW5nVmlldykgLSBwb3NpdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb25lQWxyZWFkeVdvcmtlZDtcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBmaXJpbmcgYSBhbmltYXRpb24gZmluaXNoIGV2ZW50XG4gICAqIEBwYXJhbSB2YWx1ZSBXaGV0aGVyIHRoZSBhbmltYXRpb24gZmluaXNoZWQgYXQgdGhlIHRhcmdldCAodHJ1ZSkgb3IgZ290IGludGVycnVwdGVkIChmYWxzZSlcbiAgICovXG4gIHB1YmxpYyBmaXJlRXZlbnQodmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxGaW5pc2hMaXN0ZW5lcikge1xuICAgICAgdGhpcy5wYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxGaW5pc2hMaXN0ZW5lci5lbWl0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIHRoZSBpbnRlcnJ1cHQgbGlzdGVuZXJzIHRvIHRoZSBQYWdlU2Nyb2xsSW5zdGFuY2UgYm9keS4gVGhlIGdpdmVuIGludGVycnVwdFJlcG9ydGVyXG4gICAqIHdpbGwgYmUgY2FsbGVkIGlmIGFueSBvZiB0aGUgYXR0YWNoZWQgZXZlbnRzIGlzIGZpcmVkLlxuICAgKlxuICAgKiBQb3NzaWJseSBhdHRhY2hlZCBpbnRlcnJ1cHRMaXN0ZW5lcnMgYXJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSBib2R5IGJlZm9yZSB0aGUgbmV3IG9uZSB3aWxsIGJlIGF0dGFjaGVkLlxuICAgKi9cbiAgcHVibGljIGF0dGFjaEludGVycnVwdExpc3RlbmVycyhpbnRlcnJ1cHRSZXBvcnRlcjogSW50ZXJydXB0UmVwb3J0ZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pbnRlcnJ1cHRMaXN0ZW5lcnNBdHRhY2hlZCkge1xuICAgICAgLy8gRGV0YWNoIHBvc3NpYmx5IGV4aXN0aW5nIGxpc3RlbmVycyBmaXJzdFxuICAgICAgdGhpcy5kZXRhY2hJbnRlcnJ1cHRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdGhpcy5pbnRlcnJ1cHRMaXN0ZW5lciA9IChldmVudDogRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgIGludGVycnVwdFJlcG9ydGVyLnJlcG9ydChldmVudCwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLnBhZ2VTY3JvbGxPcHRpb25zLmludGVycnVwdEV2ZW50cy5mb3JFYWNoKFxuICAgICAgKGV2ZW50OiBzdHJpbmcpID0+IHRoaXMucGFnZVNjcm9sbE9wdGlvbnMuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmludGVycnVwdExpc3RlbmVyKVxuICAgICk7XG4gICAgdGhpcy5pbnRlcnJ1cHRMaXN0ZW5lcnNBdHRhY2hlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBib2R5IGFuZCBzdG9wIGxpc3RlbmluZyBmb3IgZXZlbnRzIHRoYXQgbWlnaHQgYmUgdHJlYXRlZCBhcyBcImFuaW1hdGlvblxuICAgKiBpbnRlcnJ1cHRcIiBldmVudHMuXG4gICAqL1xuICBwdWJsaWMgZGV0YWNoSW50ZXJydXB0TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIHRoaXMucGFnZVNjcm9sbE9wdGlvbnMuaW50ZXJydXB0RXZlbnRzLmZvckVhY2goXG4gICAgICAoZXZlbnQ6IHN0cmluZykgPT4gdGhpcy5wYWdlU2Nyb2xsT3B0aW9ucy5kb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaW50ZXJydXB0TGlzdGVuZXIpXG4gICAgKTtcbiAgICB0aGlzLmludGVycnVwdExpc3RlbmVyc0F0dGFjaGVkID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGdldFNjcm9sbFRhcmdldEVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgIGlmICh0eXBlb2YgdGhpcy5wYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxUYXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHRoaXMucGFnZVNjcm9sbE9wdGlvbnMuc2Nyb2xsVGFyZ2V0IGFzIHN0cmluZztcbiAgICAgIGlmICh0YXJnZXRTZWxlY3Rvci5tYXRjaCgvXiNbXlxcc10rJC9nKSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJdCdzIGFuIGlkIHNlbGVjdG9yIGFuZCBhIHZhbGlkIGlkLCBhcyBpdCBkb2VzIG5vdCBjb250YWluIGFueSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzXG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZVNjcm9sbE9wdGlvbnMuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0U2VsZWN0b3Iuc3Vic3RyKDEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGFnZVNjcm9sbE9wdGlvbnMuZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXRTZWxlY3RvcikgYXMgSFRNTEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFnZVNjcm9sbE9wdGlvbnMuc2Nyb2xsVGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICB9XG59XG5cbi8qKlxuICogQW4gSW50ZXJmYWNlIGEgbGlzdGVuZXIgc2hvdWxkIGltcGxlbWVudCB0byBiZSBub3RpZmllZCBhYm91dCBwb3NzaWJsZSBpbnRlcnJ1cHQgZXZlbnRzXG4gKiB0aGF0IGhhcHBlbmVkIGR1ZSB0byB1c2VyIGludGVyYWN0aW9uIHdoaWxlIGEgc2Nyb2xsIGFuaW1hdGlvbiB0YWtlcyBwbGFjZS5cbiAqXG4gKiBUaGUgUGFnZVNjcm9sbFNlcnZpY2UgcHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gdG8gYSBQYWdlU2Nyb2xsSW5zdGFuY2UgdG8gYmUgbm90aWZpZWRcbiAqIGFib3V0IHNjcm9sbCBhbmltYXRpb24gaW50ZXJydXB0cyBhbmQgc3RvcCByZWxhdGVkIGFuaW1hdGlvbnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW50ZXJydXB0UmVwb3J0ZXIge1xuICByZXBvcnQoZXZlbnQ6IEV2ZW50LCBwYWdlU2Nyb2xsSW5zdGFuY2U6IFBhZ2VTY3JvbGxJbnN0YW5jZSk6IHZvaWQ7XG59XG4iXX0=